#!/usr/bin/env ruby

require 'pathname'
require 'yaml'
require 'parallel'
require 'thread'

$semaphore = Mutex.new

def os_walk(dir)
  root = Pathname(dir)
  files, dirs = [], []
  Pathname(root).find do |path|
    unless path == root
      dirs << path if path.directory?
      files << path if path.file?
    end
  end
  [root, files, dirs]
end

$error = []

def run_docker(name, tag, fn, fp)
    p "run:\tdocker build -t \"#{ENV["DOCKER_USER"]}/#{name}:#{tag}\" -f #{fn} #{fp}"

    system "docker build -t \"${DOCKER_USER}/#{name}:#{tag}\" -f #{fn} #{fp}"

    if $?.exitstatus > 0
      $semaphore.synchronize {
        $error << name
        puts "I failed to build docker #{name}, I am very sorry :'("
       }
    end
end

if $0 == __FILE__
  
  data = []
  
  root, files, dirs = os_walk('..')

  files.each do |f|
    if f.to_s.include? 'Dockerfile'

      name = f.dirname.each_filename.to_a.last
      
      data << { 'path' => f.to_s,
                'dir' => f.dirname.to_s,
                'docker_file' => f.basename.to_s,
                'name' => name,
                'tag' => ( f.extname == "" ? 'latest' : f.extname.to_s.gsub('.','') ) }
    end
  end

  File.open('../docker.list', 'w') {|f| f.write data.to_yaml }
  
  Parallel.map(data, in_processes: 4) { |docker|
    p "build docker #{docker["name"]}..."
    p "using path #{docker["path"]}"
    
    run_docker(docker['name'],docker['tag'],docker['path'],docker['dir'])
  }

  p $error
  
end
